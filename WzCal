#include<cmath>
#define MAX 100
class Cal
{
public:
	//操作数栈
	double nums[MAX];
	//下一个插入位置
	int numIndex = 0;

	//符号栈
	char operators[MAX];
	//下一个插入位置
	int operIndex = 0;

	//str当前处理 index
	int index = 0;

	double cal(const char* str, int len) {

		while (index < len) {
			//操作符 左括号直接入栈
			if (isOperator(str[index]) || str[index] == '(') {
				operators[operIndex++] = str[index++];
			}
			//右括号 计算括号内表达式
			else if (str[index] == ')') {
				while (operators[operIndex - 1] != '(') {
					calTwoInStack();
				}
				//skip )
				index++;
				//skip (
				operIndex--;
			}
			else {
				double num = 0;
				bool frac = false;
				int fracDigits = -1;

				//这个while读取数字到num中
				while (index < len && (!isOperator(str[index]) && !isBracket(str[index]))) {
					if (isDigit(str[index])) {
						if (!frac) {
							num = num * 10 + str[index] - '0';
						}
						else {
							num = num + (str[index] - '0') * pow(10, fracDigits);
							fracDigits--;
						}
					}
					else if (str[index] == '.') {
						frac = true;
					}
					index++;
				}
				nums[numIndex++] = num;

				//对当前数字的下一个字符分2种情况
				//1 str结尾        计算->结束				
				//2 操作符         判断前一个操作符优先级是否小于下一个 否 计算->继续
				if (index >= len) {
					while (operIndex > 0) {
						calTwoInStack();
					}
				}				
				else if (operIndex && operators[operIndex - 1]!='(' && notLess(operators[operIndex - 1], str[index])) {
					calTwoInStack();
				}
			}
		}

		//处理最后是）的特殊情况
		while (operIndex > 0) {
			calTwoInStack();
		}
		return nums[0];
	}
	bool isOperator(char c) {
		return c == '+' || c == '-' || c == '*' || c == '/';
	}
	bool isBracket(char c) {
		return c == '(' || c == ')';
	}
	bool isDigit(char c) {
		return c >= '0' && c <= '9';
	}
	bool notLess(char first, char second) {
		return (first == '*' || first == '/') && (second == '+' || second == '-');
	}
	double calTwo(double first, double second, char oper) {
		switch (oper)
		{
		case '+':
			return first + second;
		case '-':
			return first - second;
		case '*':
			return first * second;
		case '/':
			//todo second=0
			return first / second;
		}
		return 0;
	}
	void calTwoInStack() {
		double tmp = calTwo(nums[numIndex - 1], nums[numIndex - 2], operators[operIndex - 1]);
		nums[numIndex - 2] = tmp;
		operIndex--;
		numIndex--;
	}
};

void main() {
	Cal c;
	c.cal("(1.1+(1.1+1.1))*3+1.1*(1+1)", 27);
}
